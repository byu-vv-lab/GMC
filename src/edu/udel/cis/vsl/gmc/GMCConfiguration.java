package edu.udel.cis.vsl.gmc;

import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;

import edu.udel.cis.vsl.gmc.Option.OptionType;

/**
 * <p>
 * A GMCConfiguration encapsulates a set of key-value pairs, where the keys
 * correspond to commandline parameters and the value is the value assigned to
 * that parameter. In addition, there can be any number of "free arguments" that
 * are not assigned to any parameter. The free arguments are always strings.
 * </p>
 * 
 * <p>
 * A configuration is typically generated by parsing a command line, or at least
 * the suffix of a command line after the initial command(s). The command line
 * suffix <code>-verbose -errBound=10 filename.c</code>, for example, would
 * yield a configuration in which "verbose" is mapped to true, "errBound" is
 * mapped to the integer 10, and with one free argument "fileName.c".
 * </p>
 * 
 * <p>
 * A configuration has associated to it a set of options, which are specified
 * when the configuration is instantiated.
 * </p>
 * 
 * <p>
 * Each option is an instance of class {@link Option}. An option has a name and
 * a type. The type is one of STRING, INTEGER, DOUBLE, BOOLEAN, or MAP. The type
 * determines the kind of value that can be assigned to an option. The first
 * four are "scalar" types and take values of type String, Integer, Double, and
 * Boolean, respectively.
 * </p>
 * 
 * <p>
 * An option of MAP type may be assigned a value of type Map<String,Object>.
 * This kind of option is provided for command line arguments such as
 * <code>-inputX=10 -inputB=true -inputZ="hello"</code>. This constructs a map
 * from String to Object which maps "X" to the Integer 10, "B" to the Boolean
 * true, and "Z" to the String "hello". This map is the value that is assigned
 * to the option named "input". In general, the values of the map can be any
 * scalar values, and their types will be inferred from their format. For
 * example 1.0 will be interpreted as a Double, 1 as an Integer, "1" (with
 * quotes) a String.
 * </p>
 * 
 * 
 * @author Stephen F. Siegel
 * 
 */
public class GMCConfiguration {

	// Instance fields...

	/**
	 * Map from option name to option, for all options associated to this
	 * configuration.
	 */
	private Map<String, Option> optionMap = new LinkedHashMap<>();

	/**
	 * Map from option to value assigned to that option. Only options that have
	 * a non-null value assigned to them will have an entry in this map.
	 */
	private Map<Option, Object> valueMap = new LinkedHashMap<>();

	/**
	 * The list of free arguments associated to this configuration.
	 */
	private ArrayList<String> freeArgs = new ArrayList<>();

	// Constructors...

	/**
	 * Constructs new configuration with the set of options obtained from the
	 * given collection. The set of options associated to this configuration is
	 * determined from the given collection. Duplicates in the collection will
	 * be ignored. The new configuration will be empty: i.e., it will have no
	 * entries, i.e., nothing will be assigned to any option.
	 * 
	 * @param options
	 *            a collection of non-null options; duplicates will be ignored.
	 *            The options must have distinct names
	 * @throws IllegalArgumentException
	 *             if two options in the collection have the same name
	 */
	public GMCConfiguration(Collection<Option> options) {
		for (Option option : options) {
			if (optionMap.put(option.name(), option) != null)
				throw new IllegalArgumentException("Saw two options named "
						+ option.name());
		}
	}

	// Helper methods...

	/**
	 * Checks that the given option is associated to this configuration.
	 * 
	 * @param option
	 *            an Option
	 * @throws IllegalArgumentException
	 *             if the given option is not associated to this configuration
	 */
	private void checkContainsOption(Option option) {
		Option actual = optionMap.get(option.name());

		if (actual == null || !actual.equals(option))
			throw new IllegalArgumentException("Option " + option
					+ " is not associated to this configuration");
	}

	private static String escapeString(String string) {
		String result = string;

		result = result.replace("\\", "\\" + "\\");
		result = result.replace("\n", "\\" + "n");
		result = result.replace("\t", "\\" + "t");
		result = result.replace("\"", "\\" + "\"");
		result = "\"" + result + "\"";
		return result;
	}

	private static void printValue(PrintStream out, Object value) {
		if (value instanceof String) {
			out.print(escapeString((String) value));
		} else
			out.print(value);
	}

	// Public methods...

	/**
	 * Returns the set of options associated to this configuration. This returns
	 * all options associated to this configuration, not just those that have a
	 * value assigned to them.
	 * 
	 * @return the set of options
	 */
	public Collection<Option> getOptions() {
		return optionMap.values();
	}

	/**
	 * Returns the option with the given name associated to this configuration,
	 * or null if there is none.
	 * 
	 * @param name
	 *            the name of an option
	 * @return the option with that name
	 */
	public Option getOption(String name) {
		return optionMap.get(name);
	}

	/**
	 * Gets the value associated to an option or null if no value is associated
	 * to that option.
	 * 
	 * @param option
	 *            an option associated to this configuration
	 * @return the value assigned to the option or null
	 * @throws IllegalArgumentException
	 *             if the given option is not associated to this configuration
	 */
	public Object getValue(Option option) {
		checkContainsOption(option);
		return valueMap.get(option);
	}

	/**
	 * Returns the value associated to an option or the default value for that
	 * option if no value is associated to it.
	 * 
	 * @param option
	 *            an option associated to this configuration
	 * @return the value assigned to the option or the option's default value
	 * @throws IllegalArgumentException
	 *             if the given option is not associated to this configuration
	 */
	public Object getValueOrDefault(Option option) {
		Object value = getValue(option);

		if (value == null)
			return option.defaultValue();
		else
			return value;
	}

	/**
	 * Gets the map value associated to an option of map type, or null if no
	 * value is associated to that option.
	 * 
	 * @param option
	 *            an option of map type controlled by this configuration
	 * @return the map value associated to the option or null
	 * @throws IllegalArgumentException
	 *             if the given option does not have map type or is not
	 *             associated to this configuration
	 */
	@SuppressWarnings("unchecked")
	public Map<String, Object> getMapValue(Option option) {
		checkContainsOption(option);
		if (option.type() != OptionType.MAP)
			throw new IllegalArgumentException(
					"Expected option of map type, say type " + option.type()
							+ " in option " + option.name());
		return (Map<String, Object>) valueMap.get(option);
	}

	/**
	 * Determines whether the value associated to a boolean option should be
	 * construed as true in most circumstances. Specifically: if there is a
	 * value associated to this option, this method will return that value. If
	 * there is no value associated to this option but the default value for the
	 * option is true, this method will return true, otherwise it will return
	 * false.
	 * 
	 * @param option
	 *            an option of boolean type controlled by this configuration
	 * @return true iff there is a value associated to that option and it is
	 *         true or there is no value associated to the option and the
	 *         option's default value is true
	 * @throws IllegalArgumentException
	 *             if the given option is not associated to this configuration
	 *             or does not have boolean type
	 */
	public boolean isTrue(Option option) {
		checkContainsOption(option);
		if (option.type() != OptionType.BOOLEAN)
			throw new IllegalArgumentException(
					"Expected option of boolean type, saw type "
							+ option.type() + " in option " + option.name());
		else {
			Boolean value = (Boolean) getValue(option);

			if (value != null)
				return value;
			value = (Boolean) option.defaultValue();
			return value != null && value;
		}
	}

	/**
	 * Returns the current number of free arguments associated to this
	 * configuration.
	 * 
	 * @return number of free arguments
	 */
	public int getNumFreeArgs() {
		return freeArgs.size();
	}

	/**
	 * Returns the i-th free argument, indexed from 0.
	 * 
	 * @param i
	 *            integer in range 0..n-1, where n is the current number of free
	 *            arguments assigned to this configuration
	 * @return the i-th free argument
	 */
	public String getFreeArg(int i) {
		return freeArgs.get(i);
	}

	/**
	 * Adds a free argument to the list of free arguments associated to this
	 * configuration.
	 * 
	 * @param arg
	 *            a String
	 */
	public void addFreeArg(String arg) {
		freeArgs.add(arg);
	}

	/**
	 * Adds the key-value pair for a scalar value to the parameter map. If an
	 * entry with that key already exists, it is replaced by the new one. If the
	 * value is null, this instead removes the entry with that key (if one
	 * exists), returning the old entry.
	 * 
	 * @param key
	 *            a non-null string, the name of the parameter
	 * @param value
	 *            the value to associate to the parameter; either null or a
	 *            non-null Boolean, Integer, Double, or String
	 * @return the previous value associated to key, or null if there was none
	 * @throws IllegalArgumentException
	 *             if option is not associated to this configuration, or if
	 *             value does not have a type compatible with the type of the
	 *             option, or if the option has MAP type
	 */
	public Object setScalarValue(Option option, Object value) {
		checkContainsOption(option);
		if (value == null)
			return valueMap.remove(option);
		switch (option.type()) {
		case BOOLEAN:
			if (value instanceof Boolean)
				return valueMap.put(option, value);
			else
				throw new IllegalArgumentException("Option " + option.name()
						+ ": expected boolean, saw " + value);
		case DOUBLE:
			if (value instanceof Double)
				return valueMap.put(option, value);
			if (value instanceof Float)
				return valueMap.put(option, new Double((Float) value));
			if (value instanceof Integer)
				return valueMap.put(option, new Double((Integer) value));
			else
				throw new IllegalArgumentException("Option " + option.name()
						+ ": expected double, saw " + value);
		case INTEGER:
			if (value instanceof Integer)
				return valueMap.put(option, value);
			else
				throw new IllegalArgumentException("Option " + option.name()
						+ ": expected integer, saw " + value);
		case MAP:
			throw new IllegalArgumentException("Expected scalar value, saw map");
		case STRING:
			if (value instanceof String)
				return valueMap.put(option, value);
			else
				throw new IllegalArgumentException("Option " + option.name()
						+ ": expected string, saw " + value);
		default:
			throw new RuntimeException("unreachable");
		}
	}

	/**
	 * Sets map value or removes map entry from this configuration.
	 * 
	 * @param option
	 *            an option of MAP type associated to this configuration
	 * @param value
	 *            a map to assign to that option, or null
	 * @return the old map value associated to the option, or null if there
	 *         wasn't one
	 * @throws IllegalArgumentException
	 *             if the option is not associated to this configuration, or if
	 *             option's type is not MAP
	 */
	public Map<String, Object> setMapValue(Option option,
			Map<String, Object> value) {
		checkContainsOption(option);
		if (value == null) {
			@SuppressWarnings("unchecked")
			Map<String, Object> result = (Map<String, Object>) valueMap
					.remove(option);

			return result;
		}
		if (option.type() != OptionType.MAP)
			throw new IllegalArgumentException(
					"Expected option of map type, saw type " + option.type()
							+ " in option " + option.name());
		else {
			@SuppressWarnings("unchecked")
			Map<String, Object> result = (Map<String, Object>) valueMap.put(
					option, value);

			return result;
		}
	}

	/**
	 * Given an option of map type, adds or removes the key-value pair to the
	 * map corresponding to that option.
	 * 
	 * If the given option does not currently have an assigned value, a new
	 * empty map is created for it.
	 * 
	 * If the key is null, this removes the entry with that key if one exists.
	 * 
	 * @param option
	 *            an option of map type that is associated to this configuration
	 * @param key
	 *            a string which is the key for the map entry
	 * @param value
	 *            a scalar value which is an instance of one of String, Integer,
	 *            Double, or Boolean
	 * @return the previous value associated to that key or null if there was
	 *         none
	 * 
	 * @throws IllegalArgumentException
	 *             if the given option is not associated to this configuration,
	 *             or it does not have map type
	 */
	public Object putMapEntry(Option option, String key, Object value) {
		Map<String, Object> map = getMapValue(option);

		if (map == null) {
			map = new LinkedHashMap<String, Object>();
			valueMap.put(option, map);
		}
		if (value == null)
			return map.remove(key);
		else
			return map.put(key, value);
	}

	/**
	 * Returns a deep copy of this configuration. The two configurations will
	 * share references to the same options, and to the same Strings, but not to
	 * anything else. As options and strings are immutable, this should not be a
	 * problem.
	 * 
	 * @return deep copy of this configuration
	 */
	@Override
	public GMCConfiguration clone() {
		GMCConfiguration result = new GMCConfiguration(getOptions());
		int numArgs = getNumFreeArgs();

		for (int i = 0; i < numArgs; i++)
			result.addFreeArg(getFreeArg(i));
		for (Entry<Option, Object> entry : valueMap.entrySet()) {
			Option option = entry.getKey();
			OptionType type = option.type();

			if (type == OptionType.MAP) {
				@SuppressWarnings("unchecked")
				Map<String, Object> map = (Map<String, Object>) entry
						.getValue();

				for (Entry<String, Object> mapEntry : map.entrySet())
					result.putMapEntry(option, mapEntry.getKey(),
							mapEntry.getValue());
			} else {
				result.setScalarValue(option, entry.getValue());
			}
		}
		return result;
	}

	/**
	 * Prints the current state of this configuration in a manner similar to
	 * what would appear on a commandline. Each scalar assignment appears on one
	 * line.
	 * 
	 * @param out
	 *            print stream to which to print
	 */
	public void print(PrintStream out) {
		for (Entry<Option, Object> entry : valueMap.entrySet()) {
			Option option = entry.getKey();
			OptionType optionType = option.type();
			String optionName = option.name();

			if (optionType == OptionType.MAP) {
				@SuppressWarnings("unchecked")
				Map<String, Object> map = (Map<String, Object>) entry
						.getValue();

				for (Entry<String, Object> mapEntry : map.entrySet()) {
					out.print("-" + optionName + mapEntry.getKey());
					out.print("=");
					printValue(out, mapEntry.getValue());
					out.println();
				}
			} else {
				out.print("-" + optionName + "=");
				printValue(out, entry.getValue());
				out.println();
			}
		}
		out.flush();
	}

}
