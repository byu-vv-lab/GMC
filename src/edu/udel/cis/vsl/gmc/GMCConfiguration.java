package edu.udel.cis.vsl.gmc;

import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;

import edu.udel.cis.vsl.gmc.Option.OptionType;

/**
 * A GMCConfiguration encapsulates a set of key-value pairs, where the keys
 * correspond to commandline parameters and the value is the value associated to
 * that parameter. In addition, there can be any number of "free arguments" that
 * are not associated to a parameter.
 * 
 * A configuration is typically generated by parsing a command line, or at least
 * the suffix of a command line after the initial command(s). The command line
 * suffix "-verbose -errBound=10 filename.c", for example, would yield a
 * configuration in which "verbose" is mapped to true, "errBound" is mapped to
 * the integer 10, and with one free argument "fileName.c".
 * 
 * 
 * @author siegel
 * 
 */
public class GMCConfiguration {

	/**
	 * Map from option name to option.
	 */
	private Map<String, Option> optionMap = new LinkedHashMap<>();

	/**
	 * Map from option to value assigned to that option.
	 */
	private Map<Option, Object> valueMap = new LinkedHashMap<>();

	private ArrayList<String> freeArgs = new ArrayList<>();

	public GMCConfiguration(Collection<Option> options) {
		for (Option option : options) {
			optionMap.put(option.name(), option);
			this.setValue(option, option.defaultValue());
		}
	}

	public Option getOption(String name) {
		return optionMap.get(name);
	}

	public Object getValue(Option option) {
		return valueMap.get(option);
	}

	public Object getValue(String name) {
		return valueMap.get(getOption(name));
	}

	public Integer getIntValue(String name) {
		return (Integer) getValue(name);
	}

	public String getStringValue(String name) {
		return (String) getValue(name);
	}

	public Double getDoubleValue(String name) {
		return (Double) getValue(name);
	}

	public Boolean getBooleanValue(String name) {
		return (Boolean) getValue(name);
	}

	@SuppressWarnings("unchecked")
	public Map<String, Object> getMapValue(String name) {
		return (Map<String, Object>) getValue(name);
	}

	public int getNumFreeArgs() {
		return freeArgs.size();
	}

	public String getFreeArg(int i) {
		return freeArgs.get(i);
	}

	public void addFreeArg(String arg) {
		freeArgs.add(arg);
	}

	/**
	 * Adds the key-value pair to the parameter map. If an entry with that key
	 * already exists, it is replaced by the new one. If the value is null, this
	 * instead removes the entry with that key (if one exists), returning the
	 * old entry.
	 * 
	 * @param key
	 *            a non-null string, the name of the parameter
	 * @param value
	 *            the value to associate to the parameter; either null or a
	 *            non-null Boolean, Integer, Double, or String
	 * @return the previous value associated to key, or null if there was none
	 * @throws IllegalArgumentException
	 *             if key or value is null, or if value is not an instance of
	 *             either Boolean, Integer, Double, or String
	 */
	public Object setValue(Option option, Object value) {
		if (option == null)
			throw new IllegalArgumentException("setValue given null option");
		if (value == null)
			return valueMap.remove(option);
		switch (option.type()) {
		case BOOLEAN:
			if (value instanceof Boolean)
				return valueMap.put(option, value);
			else
				throw new IllegalArgumentException("Option " + option.name()
						+ ": expected boolean, saw " + value);
		case DOUBLE:
			if (value instanceof Double)
				return valueMap.put(option, value);
			if (value instanceof Float)
				return valueMap.put(option, new Double((Float) value));
			if (value instanceof Integer)
				return valueMap.put(option, new Double((Integer) value));
			else
				throw new IllegalArgumentException("Option " + option.name()
						+ ": expected double, saw " + value);
		case INTEGER:
			if (value instanceof Integer)
				return valueMap.put(option, value);
			else
				throw new IllegalArgumentException("Option " + option.name()
						+ ": expected integer, saw " + value);
		case MAP:
			if (value instanceof Map<?, ?>)
				return valueMap.put(option, value);
			else
				throw new IllegalArgumentException("Option " + option.name()
						+ ": expected map, saw " + value);
		case STRING:
			if (value instanceof String)
				return valueMap.put(option, value);
			else
				throw new IllegalArgumentException("Option " + option.name()
						+ ": expected string, saw " + value);
		default:
			throw new RuntimeException("unreachable");
		}
	}

	/**
	 * Given an option of map type, adds the key-value pair to the map
	 * corresponding to that option.
	 * 
	 * @param option
	 *            an option of map type
	 * @param key
	 *            a string which is the key
	 * @param value
	 *            a value which is an instance of one of String, Integer,
	 *            Double, or Boolean
	 * @return the previous value associate to that key or null if there was
	 *         none
	 * 
	 * @throws IllegalArgumentException
	 *             if the given option does not have map type
	 */
	public Object putMapEntry(Option option, String key, Object value) {
		if (option.type() != OptionType.MAP)
			throw new IllegalArgumentException("Option " + option.name()
					+ " has type " + option.type() + ", not map");
		else {
			@SuppressWarnings("unchecked")
			Map<String, Object> map = (Map<String, Object>) valueMap
					.get(option);

			if (map == null) {
				map = new LinkedHashMap<String, Object>();
				valueMap.put(option, map);
			}
			if (value == null)
				return map.remove(key);
			else
				return map.put(key, value);
		}
	}

	private static String escapeString(String string) {
		String result = string;

		result = result.replace("\\", "\\" + "\\");
		result = result.replace("\n", "\\" + "n");
		result = result.replace("\t", "\\" + "t");
		result = result.replace("\"", "\\" + "\"");
		result = "\"" + result + "\"";
		return result;
	}

	private static void printValue(PrintStream out, Object value) {
		if (value instanceof String) {
			out.print(escapeString((String) value));
		} else
			out.print(value);
	}

	public void print(PrintStream out) {
		for (Entry<Option, Object> entry : valueMap.entrySet()) {
			Option option = entry.getKey();
			OptionType optionType = option.type();
			String optionName = option.name();

			if (optionType == OptionType.MAP) {
				@SuppressWarnings("unchecked")
				Map<String, Object> map = (Map<String, Object>) entry
						.getValue();

				for (Entry<String, Object> mapEntry : map.entrySet()) {
					out.print("-" + optionName + mapEntry.getKey());
					out.print("=");
					printValue(out, mapEntry.getValue());
					out.println();
				}
			} else {
				out.print("-" + optionName + "=");
				printValue(out, entry.getValue());
				out.println();
			}
		}
		out.flush();
	}

}
